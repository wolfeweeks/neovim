vim.keymap.set("n", "<leader>gs", ":Git<CR>", { noremap = true, silent = true, desc = "Git status (Fugitive)" })

-- Make <CR> in :Git status open the file in a right-side vsplit
vim.api.nvim_create_autocmd("FileType", {
  pattern = "fugitive",
  callback = function(ev)
    vim.opt_local.splitright = true

    vim.keymap.set("n", "<CR>", function()
      -- parse filename from the status line (works even if cursor is on the "M")
      local line = vim.fn.getline(".")
      local file = line:match("^%s*[%w%?][%w%? ]*%s+(.+)$")

      if file and #file > 0 then
        -- Open the file in a vertical split on the right (in the TOP row),
        -- then move *into that split* before making it full height.
        vim.cmd("rightbelow Gvsplit " .. vim.fn.fnameescape(file))
        vim.cmd("wincmd l")  -- go to the new right-hand split
        vim.cmd("wincmd L")  -- make THIS split the full-height right column

        -- ensure MiniDiff overlay toggles after the new buffer is fully ready
        local buf = vim.api.nvim_get_current_buf()
        vim.schedule(function()
          local md = require("mini.diff")
          pcall(md.attach, buf)          -- harmless if already attached
          pcall(md.toggle_overlay, buf)  -- toggle overlay for this buffer
        end)
      else
        vim.cmd("normal! <CR>")
      end
    end, { buffer = ev.buf, silent = true, desc = "Fugitive: open file at cursor in right vsplit" })
  end,
})

-- === Generate commit message with OpenCode in Fugitive's commit buffer ===
local function _sanitize_output(text)
  -- If the model wraps output in ``` blocks, strip them.
  text = text:gsub("^%s*```%w*%s*", ""):gsub("%s*```%s*$", "")
  -- Trim leading/trailing whitespace
  return (text:gsub("^%s+", ""):gsub("%s+$", ""))
end

local function _git_root()
  local ok, res = pcall(vim.system, { "git", "rev-parse", "--show-toplevel" }, { text = true })
  if not ok or not res then return nil end
  local waited = res:wait()
  if waited.code ~= 0 then return nil end
  return (waited.stdout or ""):gsub("%s+$", "")
end

local function generate_commit_message()
  -- Make sure we have opencode installed
  if vim.fn.executable("opencode") == 0 then
    vim.notify("`opencode` not found on PATH", vim.log.levels.ERROR)
    return
  end

  local root = _git_root()
  if not root or #root == 0 then
    vim.notify("Not inside a git repository", vim.log.levels.ERROR)
    return
  end

  -- Quick check: ensure there are staged changes
  local staged = vim.system({ "git", "diff", "--cached", "--name-only" }, { cwd = root, text = true }):wait()
  if staged.code ~= 0 then
    vim.notify("Failed to inspect staged changes", vim.log.levels.ERROR)
    return
  end
  if (staged.stdout or ""):gsub("%s+", "") == "" then
    vim.notify("No staged changes. Stage files before generating a message.", vim.log.levels.WARN)
    return
  end

  -- Ask OpenCode for a clean, Conventional Commit–style message.
  local prompt = table.concat({
    "Generate a concise, high-quality commit message from the *staged* diff.",
    "Rules:",
    "- Use imperative mood (e.g., \"fix:\", \"feat:\"). Prefer Conventional Commits if possible.",
    "- Keep the subject ≤ 72 chars.",
    "- If helpful, include a short body with wrapped lines (≤ 72 chars) and bullets.",
    "- Do *not* include code fences or markdown headings.",
    "- Base it strictly on the staged diff. If you need file context, read files in the diff.",
  }, "\n")

  -- You already use OpenCode’s “read all files in the diff” style; we’ll let it handle that.
  local result = vim.system(
    { "opencode", "run", prompt .. "\n\nUse: git status, git diff --cached, and read all files in the staged diff." },
    { cwd = root, text = true }
  ):wait(60000)

  if result.code ~= 0 then
    vim.notify("OpenCode error: " .. (result.stderr or "unknown"), vim.log.levels.ERROR)
    return
  end

  local msg = _sanitize_output(result.stdout or "")
  if msg == "" then
    vim.notify("OpenCode returned empty message", vim.log.levels.WARN)
    return
  end

  -- Split commit buffer into "header" (before first #) and "comment" lines
  local bufnr = vim.api.nvim_get_current_buf()
  local all_lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)

  -- Find first comment line
  local first_comment = nil
  for i, line in ipairs(all_lines) do
    if line:match("^#") then
      first_comment = i
      break
    end
  end

  local generated = vim.split(msg, "\n", { plain = true })

  if first_comment then
    -- Replace everything before the comment block with the generated message
    vim.api.nvim_buf_set_lines(bufnr, 0, first_comment - 1, false, generated)
  else
    -- No comment block? just replace whole buffer
    vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, generated)
  end
  vim.cmd.normal({ args = { "gg" }, bang = true })
  vim.notify("Commit message generated by OpenCode ✓", vim.log.levels.INFO)
end

-- Create mapping/command when the Fugitive commit buffer opens
vim.api.nvim_create_autocmd("FileType", {
  pattern = "gitcommit",
  callback = function(args)
    vim.api.nvim_buf_create_user_command(args.buf, "AICommit", generate_commit_message, {})
    vim.keymap.set(
      "n",
      "<leader>gm",
      generate_commit_message,
      { buffer = args.buf, silent = true, desc = "Generate commit message with OpenCode" }
    )
  end,
})
